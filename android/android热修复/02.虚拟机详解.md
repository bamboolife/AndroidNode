### 概述
- java虚拟机结构解析
- Dalvik与JVM的不同
- ART比Dalvik有哪些优势

### java虚拟机结构解析
- JVM整体结构讲解
- java代码的编译和执行过程
- 内存管理和垃圾回收

jvm结构
![iamge](/image/jvm.png)

### 编译流程

源代码->词法分析器->Tokrn流->语法分析器->语法树/抽象语法树->语义解析器->注解抽象语法树->字节码生成器->JVM字节码   java源码级编译器

### 类加载器

![image](/image/classloader.png)

### 加载流程

1. loading：类的信息从文件中获取并且载入到JVM的内存里

2. Verifying：检查读入的结构是否符合JVM规范的描述

3. Preparing：分配一个结构用来存储类信息

4. Resolving：把这个类的常量池中的所有符号引用改变成直接引用
 
5. Initializing：执行静态初始化程序，把静态变量初始化成指定的值

### JVM内存管理

#### java栈区
- 作用：它存放的是java方法执行时的所有数据
- 组成：由栈帧组成，一个栈帧代表一个方法的执行

1. java栈帧
- 定义：每个方法从调用到执行 完成就对应一个栈帧在虚拟机栈中入栈到出站
- 栈帧包含的内容：局部变量表、栈操作数、动态链接、方法出口 

2. 本地方法栈
- 作用：本地方法栈是专门为Native方法服务的

3. 方法区
- 存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后等数据

4.  堆区
- 作用：所有通过new创建的对象的内存都在堆中分配
- 特点：是虚拟机中最大的一块内存，是GC要回收的本分

### 垃圾回收
1. 垃圾收集算法
- 引用计数算法
**缺陷**
互相引用即使没有指向的路径 但是也不会销毁

- 可达性算法

### 引用的类型
- 强引用、软引用、弱引用、虚引用
- 最常使用的就是强引用和弱引用

#### 弱引用的创建
弱引用的创建必须依赖于强引用
```java
Object obj=new Object();
WeakReference<Object> wf=new WeakReference<Object>(obj);
obj=null;
wf.get();
```
### 垃圾回收算法
1. 标记-清除算法
**好处**
不需要对象的移动并且仅对不存活的对象进行处理，在存活对象多的时候极为高效。
**存在的问题**
由于标记清除算法会直接回收不存活的对象，因此会造成内存碎片。不利于后续内存的分配。 

2. 复制算法
**优势**
当存活的对象比较少时，极为的高效，
**劣势**
需要一块内存作为交换空间，来对像的移动

3. 标记-整理算法

### 垃圾回收触发
- java虚拟机无法再为新的对象分配空间了
- 手动调用System.gc()方法（不推荐）
- 低优先级的GC线程，被运行时就会执行GC

### Dalvik VM和JVM的不同
- 执行的文件不同，一个是class，一个是dex
- 类加载的系统与JVM区别比较大
- 可以同时存在多个DVM
- Dalvik是基于寄存器的，而JVM是基于栈的

### Dalvik与ART的不同

-  DVM使用JIT来将字节码转换成机器码，效率低
-  ART采用了AOT预编译技术，执行速度快
-  ART会占用更多的应用安装时间和存储空间






