### 前言
- 最近在对项目进行重构，希望能利用设计模式使得自己的代码能更加简化 & 优雅一些，所以对设计模式进行了一系列的总结
- 今天我带你来了解一切关于设计模式的知识。

### 目录
- 1.定义
- 2.作用
- 3.设计原则
- 4.设计模式的分类
	- **4.1创建型**
	- **4.2结构型**
	- **4.3行为型**
- 总结

### 1.定义
- 某类特定问题的代码设计解决方案
- 是一套代码设计的经验总结	
> 设计模式，其实只是前人针对某类问题的代码设计经验而已，并没有很高大上

### 2.作用

- 提高代码复用率，降低开发成本和周期
- 提高代码可维护性、可拓展性
- 使代码更加优雅
- 让代码更容易被他人理解

### 3.设计模式的设计原则

在设计模式进行设计时需要遵循以下的原则：

- 单一职责原则
一个类=只有一个引起它变化的原因。
> 如果一个类承担的职责过多，即耦合性太高=一个职责的变化可能会影响到其他的职责

- 开放封闭原则

一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭
> 1.即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。<br>
2.符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。

- 里氏代替原则

子类必须替换掉它们的父类型。

> 1.在软件开发过程中，子类替换父类后，程序的行为是一样的。<br>
2.只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。

- 依赖倒置原则

细节应该依赖于抽象，而抽象不应该依赖于细节。
> 所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。

- 接口隔离原则

使用多个专门功能的接口，而不是使用单一的总接口。

> 使用多个专门功能的接口，而不是使用单一的总接口。

- 合成复用原则
在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。

> 新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

- 最少知识原则（迪米特法则）

一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。
> 1.关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。<br>
2.外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。

### 设计模式分类

在介绍完设计模式的设计原则后，是时候带大家了解下设计模式一共有哪些：

#### 第一类：创建类

- 本质：创建对象的模式：对类的实例化进行抽象
- 特点：
	- 1.封装了具体类的信息
	- 2.隐藏了类的实例化过程
- 5中设计模式：
	- 单例模式（singleton）
	- 工厂方法模式（Factory Method）
	- 抽象工厂模式（Abstract Factory）
	- 建造者模式（Builder）
	- 原始模式（Prototype）

#### 结构型

- 本质：处理类或对象的组合
- 两种类型：
	- 1.类结构型：采用继承机制来组合接口实现
	- 2.对象结构型：组合对象的方式来实现新功能
- 7种设计模式：
	- 适配器模式（Adapter）
	- 桥梁模式（Bridge）
	- 装饰模式（Decorator）
	- 门面模式（Facade）
	- 合成模式（composite）
	- 享元模式 (Flyweight）
	- 代理模式（Proxy)

#### 第三类：行为类
- 本质： 对在不同的对象之间划分责任和算法的抽象画
- 两种类型：
	- 1.类的行为模式：使用继承关系在几个类之间分配行为
	- 2.对象的行为模式：使用对象聚合的方式来分配行为
- 11中设计模式
	- 模板方法模式（Template Method）	
	- 命令模式（Command）
	- 迭代器模式（Iterator）
	- 观察者模式（Observer）
	- 调停者模式（Mediator）
	- 状态模式（State）
	- 策略模式（Strategy）
	- 责任链模式（Chain of Responsibility）
	- 访问者模式（Visitor）
	- 备忘录模式（Memento）
	- 解释器模式（Interpreter）




























